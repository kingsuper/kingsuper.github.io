---
layout: post
title: Go 语言圣经学习笔记-复合数据类型
category: 技术
---


## 4.2 Slice

slice 表示一个拥有相同类型元素的可变长度的序列。slice是和数组紧密关联的，slice是一种轻量的数据结构，可以用来访问数组的部分或者全部的元素，而这个数组称为slice的底层数组。
slice有三个属性：指针、长度和容量。指针指向数组第一个可以从slice中访问的元素，而这个元素不一定是数组的第一个元素，长度是指slice中元素的个数,它不能超过slice的容量。容量的大小一般是底层数组的大小。Go的内置函数len和cap可以返回slice的长度和容量。

如果slice的引用超过被引用对象的容量，就会Panic，但是如果只是超出了被引用对象的长度，即len(s)，那么最终slice会比原slice长。

因为slice包含指向数组元素的指针，所以将slice传递给函数的是和，可以在函数内部修改底层数组的的元素。
注意slice的初始化表达式和数组的区别。slice没有指定长度，这种隐式的区别是创建有固定长度的数组和创建指向数组长度的slice。

和数组不同的是,slice不能做比较，因此不能通过==来测试两个slice是否相同。这里有两个原因：
首先，slice的元素是非直接的，有可能slice可以包含自身，虽然可以处理这种特殊情况，但是没有一种是简单、高效、直观的。
其次，因为元素不是直接的，如果底层数组改变，同一slice在不同的时间，会拥有不同的元素。由于散列表（例如map）仅对元素的键做浅拷贝，这就要求散列表的键在整个生命周期内保持不变。因为slice需要深度比较，所以不能用作Map的键。所以最安全的方法就是不允许直接比较slice。
slice唯一允许的比较是和nil做比较，但是也有非nil的slice长度和容量是0的，所以如果检查一个slice是否为空，建议使用len(s) == 0，而不是s == nil。
make可以创建一个具有指定元素类型、长度和容量的slice.

```go
make([]T,len)
make([]T,len,cap)
```

### 4.2.1 append函数

内置的append用来将元素追加到slice的后面。
append函数对于对于理解slice的工作原理很重要，每次append都必须检查是否仍有足够的容量存储数组中的新元素，如果容量足够，那么就定义一个新的slice（任然引用原始底层数组），然后插入新的元素，并返回。
如果容量不够，则必须创建一个拥有足够容量的新的底层数组来存储新元素，然后将元素从旧的slice复制到新数组，然后追加新元素。处于效率的考虑，新创建的数组容量会扩展一倍，来减少内存分配的次数。
内置的copy函数用来为两个拥有相同类型元素的slice复制元素。

为了正确的使用slice，必须记住，虽然底层数组的元素是间接引用的，但是slice的指针、长度和容量不是。要更新一个slice的指针，长度或容量必须显式赋值。

### 4.2.2 slice就地修改

对于slice的一些简单修改，可以重用底层数组，这样每一个输入值的slice最对中能有一个输出的slice结果。
slice[:0] 可以表示医用原始slice的新的零长度的slice。

## 4.3 map

散列表是设计精妙、用途广泛的数据结构之一。它是一个拥有键值对元素的无序集合。键值是唯一的，键对应的值可以通过键来获取、更新或者移除，无论散列表有多大，都可以通过常量时间的键比较完成。

go中，所有的键拥有相同的数据类型，值也拥有相同的数据类型，但是键和值的类型不一定相同。键的类型，必须是可以通过操作符==来进行比较的数据类型。
可以通过make创建一个map，也可以通过字面量创建一个字典：
```go
ages := make(map[string]int)
ages := map[string]int{
    "alice":31,
    "charlie":34,
}
```
空的map的表达方式是：map[string]int{}

可以通过内置delete函数从字典中移除一个元素：

```go
delete(ages,"alice")
```

即使键不在map中，做增删改查也是安全的，map用键查找元素，如果不存在，则返回类型的零值。
但是map不是一个变量，不可以获取它的地址，因为map的增长有可能导致元素被重新散列到新的位置，导致获取的地址无效。

可以通过for循环遍历map，但是元素中的迭代顺序是不固定的，不同的方法会使用不同的散列算法，得到不同的顺序。

map类型的零值是nil,大多数map的操作都可以安全的在零值的map上执行，和空map的行为一致，但是向零值map插入元素会导致错误。

如果需要能够辨别一个元素是否存在，还是恰好这个元素的值是0，可以通过：

```go
if age,ok := ages["bob"];!ok
```

通过下标访问map，第二个值是一个布尔值，来报告该元素是否存在。
和slice一样，map不可比较，唯一合法的比较就是和nil做比较，为了比较map是否拥有相同的键和值，必须写一个循环。

go没有提供集合类型，但是既然map的键都是唯一的，那么就可以使用map实现这个功能。

有时候，需要有一个Map,并且它的键是slice,但是slice不可比较，这个时候可以分两步走：1.定义一个帮助函数k将每一个键都映射为字符串，保证当x,y相同时，k(x)==k(y)。然后可以使用string作为map的key。

```go
var m = make(map[string]int)

func k(list []string) string{ return fmt.Sprinf("%q",list)}

func Add(list []string){ m[k(list)]++ }
func Count(list []string){ return m[k(list)] }
```

同样的方法适用于任何不可直接比较的键类型，不仅仅局限于slice。同样，k(x)的类型不一定是字符串类型，任何能够得到想要的比较结果的类型都可以，例如整数、数组或者结构体。

map的值类型本身可以是复合数据类型，例如是map或slice。

