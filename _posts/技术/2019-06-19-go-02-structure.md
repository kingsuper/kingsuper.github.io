---
layout: post
title: Go 语言圣经学习笔记-2.程序结构
category: 技术
---

## 2.1 命名

Go 命令规则：以一个字母或者下划线开头，后面可以跟任意数量的字母、数字或下划线。区分大小写。
如果一个名字在函数内部定义，则只在内部有效。如果在函数外，当前包的所有文件都可以访问。名称开头的字母的大小写决定了名字在包外的可见性。大写可见，小写不可见。
Go推荐使用驼峰命名，缩略词则避免大小写混合的写法。

## 2.2 声明

Go有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数。

## 2.3 变量

变量声明的一般语法是var 名称 类型 = 表达式。 类型和表达式可以省略一个，如果省略类型，会根据初始值推导类型。 如果没有表达式，则用零值初始化。所以Go不存在未初始化的变量。
也可以同时声明一组变量。
初始化表达式如果是包级别在main执行前初始化，局部变量则在执行的时候初始化。

### 2.3.1 简短变量声明

函数内部，可以用简单变量声明来声明和初始化。语法为：名字：=表达式。var形式的声明语句往往是用于需要显示指定变量类型的地方，或者稍后会被重新复制而初始值无关紧要的地方。

### 2.3.2 指针

指针的值是另一个变量的地址。例如var x int声明了一个变量，那么&x将产生一个该变量的指针，类型为* int，如果指针为p，那么* p对应p指针指向变量的值。
指针特别有价值的地方是可以不用名字访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者就不容易。不仅指针会创建别名，很多其他引用类型也会创建别名。

指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会分布在整个程序中。

### 2.3.3 new 函数

调用内建的new函数new(T),可以创建一个T类型的匿名变量，初始化为T类型的零值，返回变量地址，返回的指针类型为*T。

### 2.3.4 变量的生命周期

包一级声明的变量，它们的生命周期和整个程序的运行周期是一致的。局部变量的生命周期则是动态的，从创建声明语句开始，直到该变量不再被引用为止。

Go编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但是这个选择并不是由var还是new声明变量的方式决定的。

## 2.4 赋值

### 2.4.1 元组赋值

元组赋值允许同时更新多个变量的值，赋值之前，右边的所有表达式将会先进行求值，然后统一更新到左边。

### 2.4.2 可赋值性

不管是隐式还是显式的赋值，在赋值语句左边的变量和右边最终求值必须有相同的数据类型。
规则：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。
任何类型的相等比较，第二值必须是对第一个值类型对应的变量是可赋值的，反之依然。

## 2.5 类型

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使底层类型相同也是不兼容的。
type 类型名称 底层类型

只有两个类型的底层基础类型相同时，才允许这种转型操作，或者两者都是指向相同底层结构的指针类型，这些转换只改变类型。
底层数据结构决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。

一个命名的类型可以提供书写方便，特别是避免重复书写复杂类型。命名类型还可以为该类型的值定义新的行为。这些行为关联到该类型的函数集。

## 2.6 包和文件

一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中。
每个包都有对应的一个独立的名字空间。
包也通过名字是否大小写开头来控制哪些是外部可见的。
每个源文件的包声明前紧跟着的注释是包注释，通常第一句应该是包的概要说明。一个包通常只有一个源文件有包注释。

### 2.6.1 导入包

如果导入了一个包，但是又没有使用将被当做一个编译错误处理。

### 2.6.2 包的初始化

首先包的初始化，按照包级变量的声明的顺序依次初始化。如果包中多个.go源文件，则按照发给编译器的顺序初始化。

一些没有初始化表达式的，例如某些表格数据的初始化并不是一个简单的赋值过程，这种情况，使用特殊的init函数来简化初始化工作。每个文件可以有多个，不能被调用和引用。程序开始执行时，按照它们声明的顺序被自动调用。

包按照导入声明的顺序初始化，自下而上进行。

一些复杂的初始化，也可以通过将初始化逻辑包装为一个匿名函数处理。

## 2.7 作用域

声明语句的作用域对应一个源代码的文本区域，它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，是一个运行时的概念。

并没有什么特别~
